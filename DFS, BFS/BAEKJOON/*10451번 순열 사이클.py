# 10451번 순열 사이클
# https://duwjdtn11.tistory.com/522
# https://davi06000.tistory.com/85
# https://kimmeh1.tistory.com/325
# 1부터 N까지 정수로 만들 수 있는 순열의 한 가지 경우가 주어질 경우 1부터 N까지 오름차순으로 정렬한 순열과
# 1 대 1 대응하여 만들 수 있는 그래프에서 순환 구조는 몇개가 생기는지 리턴하는 함수를 구해라
# 첫째 줄에 테스트 케이스의 개수 T가 주어진다.
# 각 테스트 케이스의 첫째 줄에는 순열의 크기 N이 주어진다.
# 둘째 줄에는 순열이 주어지며, 각 정수는 공백으로 구분되어 있다.
# 각 테스트 케이스마다 입력으로 주어진 순열에 존재하는 순열 사이클의 개수를 출력한다.

# 접근 방식은 dfs를 이용한 순환구조 찾기
# dfs는 깊이를 우선으로 탐색하므로 두 갈래 혹은 세 갈래 이상의 갈림길이 나타나면 그 중 하나의 가지만을 선택해서 나아감
# 그렇게 진행된 경로는 마지막 깊이까지 탐색한 후 종료되고 바로 직전의 갈림길에서 가지 않았던 길부터 다시 탐색함
# 따라서 각 재귀에서 뻗어나가는 가지가 모두 탐색이 되었다면 진행경로에서 해당 노드를 삭제한 후 함수를 마치면 추적 가능
# 이 문제는 몇개의 순환 고리가 있는지 알아내야 하므로 한번 고리로 count된 구조에 속한 노드들은 다음 탐색에서 제외되어야함.
# 경로 추적을 위한 set()과는 별개로 방문기록을 남기는 set()을 따로 만들어야함.

# 문제의 핵심은 dfs
# 그래프를 순회하며 dfs가 실행될 때마다 cnt값을 올려주면 싸이클의 개수를 확인할 수 있음
# dfs를 순회할 때마다 연결된 노드들은 모두 순회할 것이기 때문에 dfs 한번에 사이클 한번을 순회할 수 있음.
# 값을 입력받고 순열을 모델링하여 그래프화한다. 방문 여부를 저장하기 위한 변수 visited도 정의함
# 이후 모든 노드에 방문여부를 순회하는 루프를 통해 순차적으로 접근하며 만일 i번째 노드를 방문하지 않았을 경우
# 해당 노드를 시작점으로 하는 dfs를 실행한다.

# Recursion limit을 늘려줘서 에러를 방지
import sys
sys.setrecursionlimit(10000)

def dfs(start):
    visited[start]=1 # 방문한 곳을 1로 표시
    next = path[start] # 현재 방문한 노드의 다음 노드를 next에 저장하고
    if visited[next] == 0: # next가 아직 방문하지 않은 곳인 경우 재귀 호출로 방문한다. 하지만 방문했다면 재귀가 멈추고 순환하는 그래프임을 알 수있다
        dfs(next)

T = int(sys.stdin.readline())
for _ in range(T):
    n=int(sys.stdin.readline()) #순열의 크기
    visited=[0]*(n+1)
    path=[0]+list(map(int,sys.stdin.readline().split()))

    cnt=0
    for i in range(1, n+1):
        if visited[i]==0:
            dfs(i)
            cnt+=1
    print(cnt)
